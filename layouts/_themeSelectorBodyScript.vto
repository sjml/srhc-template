<script>
	const themeSelectorGUI = document.getElementById("themeSelectorGUI");
	const themeSelect = document.getElementById("themeSelect");

	function setTheme(value) {
		document.documentElement.dataset.themeSelection = value;
		if (themeSelect && themeSelect.value !== value) {
			themeSelect.value = value;
		}
		if (document.documentElement.dataset.themeSelection == "system") {
			localStorage.removeItem("{{ sitedata.titleAbbreviation }}ThemeSelection");
		}
		else {
			localStorage.{{ sitedata.titleAbbreviation }}ThemeSelection = document.documentElement.dataset.themeSelection;
		}
	}


	if (themeSelectorGUI) {
		themeSelectorGUI.style.display = "flex";
		themeSelectorGUI.addEventListener("click", (evt) => {
			const clickPos = evt.offsetX / themeSelectorGUI.clientWidth;
			if (clickPos < 0.35) {
				setTheme("light");
			}
			else if (clickPos <= 0.65) {
				setTheme("system");
			}
			else {
				setTheme("dark");
			}
		});

		// I wish I could just let the <select> handle the keyboard inputs,
		//    but it was hard to get it working across browsers while
		//    remaining visually hidden
		// Not sure if this has accessibility implications? Probably bad,
		//    but it worked in my quick tests with screen readers
		themeSelectorGUI.addEventListener("keydown", (evt) => {
			const themes = ["light", "system", "dark"];
			const currentTheme = document.documentElement.dataset.themeSelection || "system";
			const currentIdx = themes.indexOf(currentTheme);
			let newIdx = currentIdx;
			if (evt.key === "ArrowLeft" || evt.key === "ArrowUp") {
				newIdx = Math.max(0, currentIdx - 1);
			}
			else if (evt.key === "ArrowRight" || evt.key == "ArrowDown") {
				newIdx = Math.min(themes.length - 1, currentIdx + 1);
			}
			else if (evt.key === "Home") {
				newIdx = 0;
			}
			else if (evt.key === "End") {
				newIdx = themes.length - 1;
			}
			else if (evt.key === "Enter" || evt.key === " ") {
				newIdx = (currentIdx + 1) % themes.length;
			}

			if (newIdx !== currentIdx) {
				setTheme(themes[newIdx]);
				evt.preventDefault();
			}
		});

		window.addEventListener("beforeprint", (_) => {
			themeSelectorGUI.style.display = "none";
		});
		window.addEventListener("afterprint", (_) => {
			themeSelectorGUI.style.display = "flex";
		});
	}

	if (themeSelect) {
		themeSelect.value = document.documentElement.dataset.themeSelection || "system";
		themeSelect.addEventListener("change", (evt) => {
			setTheme(evt.target.value);
			evt.preventDefault();
		});
		themeSelect.addEventListener("click", (evt) => {
			evt.stopPropagation();
		});
	}
</script>
